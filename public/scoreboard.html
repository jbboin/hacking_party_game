<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scoreboard</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      overflow: hidden;
    }

    h1 {
      font-size: 2.5rem;
      color: #00ff00;
      text-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
      margin-bottom: 2rem;
      text-transform: uppercase;
      letter-spacing: 0.3rem;
    }

    .progress-section {
      width: 100%;
      max-width: 900px;
      margin-bottom: 3rem;
    }

    .progress-container {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .team-label {
      font-size: 1.2rem;
      font-weight: bold;
      width: 80px;
      text-align: center;
    }

    .team-label.blue { color: #4488ff; }
    .team-label.red { color: #ff4444; }

    .progress-bar {
      flex: 1;
      height: 50px;
      background: #1a1a1a;
      border-radius: 10px;
      overflow: hidden;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      transition: width 0.5s ease;
      position: relative;
    }

    .progress-fill.blue {
      background: linear-gradient(90deg, #2255aa, #4488ff);
      box-shadow: 0 0 20px rgba(68, 136, 255, 0.5);
    }

    .progress-fill.red {
      background: linear-gradient(90deg, #aa2222, #ff4444);
      box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
    }

    .percent {
      font-size: 1.5rem;
      font-weight: bold;
      width: 80px;
      text-align: center;
    }

    .percent.blue { color: #4488ff; }
    .percent.red { color: #ff4444; }

    /* Teams Section */
    .teams-section {
      display: flex;
      gap: 4rem;
      width: 100%;
      max-width: 900px;
    }

    .team-box {
      flex: 1;
      padding: 1.5rem;
      border-radius: 10px;
      text-align: center;
    }

    .team-box.blue {
      background: rgba(68, 136, 255, 0.1);
      border: 2px solid #4488ff;
    }

    .team-box.red {
      background: rgba(255, 68, 68, 0.1);
      border: 2px solid #ff4444;
    }

    .team-title {
      font-size: 1.5rem;
      font-weight: bold;
      margin-bottom: 1rem;
    }

    .team-box.blue .team-title { color: #4488ff; }
    .team-box.red .team-title { color: #ff4444; }

    .top-players {
      text-align: left;
    }

    .top-player {
      display: flex;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid #333;
    }

    .top-player:last-child {
      border-bottom: none;
    }

    .rank {
      font-size: 1.2rem;
      font-weight: bold;
      width: 30px;
      color: #666;
    }

    .rank.first { color: #ffd700; }
    .rank.second { color: #c0c0c0; }
    .rank.third { color: #cd7f32; }

    .player-name {
      flex: 1;
      font-size: 1.1rem;
    }

    .player-pts {
      font-weight: bold;
      font-size: 1.1rem;
    }

    .team-box.blue .player-pts { color: #4488ff; }
    .team-box.red .player-pts { color: #ff4444; }

    .no-players {
      color: #666;
      font-style: italic;
    }

    /* Standby screen */
    .standby-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .standby-screen.hidden {
      display: none;
    }

    .standby-title {
      font-size: 3rem;
      color: #00ff00;
      text-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
      margin-bottom: 2rem;
      text-transform: uppercase;
      letter-spacing: 0.3rem;
      animation: pulse 2s ease-in-out infinite;
    }

    .standby-message {
      font-size: 1.5rem;
      color: #666;
      letter-spacing: 0.2rem;
    }

    .standby-dots {
      display: inline-block;
      width: 30px;
      text-align: left;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; text-shadow: 0 0 20px rgba(0, 255, 0, 0.5); }
      50% { opacity: 0.7; text-shadow: 0 0 40px rgba(0, 255, 0, 0.8); }
    }

    /* Winner effect */
    .team-box.winning {
      animation: glow 2s ease-in-out infinite;
    }

    .team-box.blue.winning {
      animation: glowBlue 2s ease-in-out infinite;
    }

    .team-box.red.winning {
      animation: glowRed 2s ease-in-out infinite;
    }

    @keyframes glowBlue {
      0%, 100% { box-shadow: 0 0 20px rgba(68, 136, 255, 0.3); }
      50% { box-shadow: 0 0 40px rgba(68, 136, 255, 0.6); }
    }

    @keyframes glowRed {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 68, 68, 0.3); }
      50% { box-shadow: 0 0 40px rgba(255, 68, 68, 0.6); }
    }

    /* Boss Phase Terminal */
    .boss-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
      padding: 2rem;
    }

    .boss-screen.hidden {
      display: none;
    }

    .boss-terminal {
      width: 100%;
      max-width: 900px;
      height: 80vh;
      background: #0d0d0d;
      border: 2px solid #ff9900;
      border-radius: 10px;
      box-shadow: 0 0 30px rgba(255, 153, 0, 0.3);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      transform-origin: 50% 50vh;
    }

    .boss-terminal.hidden {
      display: none;
    }

    .boss-terminal-header {
      background: linear-gradient(90deg, #1a0f00, #2a1500);
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      border-bottom: 1px solid #ff9900;
    }

    .boss-terminal-header .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .boss-terminal-header .dot.red { background: #ff5f56; }
    .boss-terminal-header .dot.yellow { background: #ffbd2e; }
    .boss-terminal-header .dot.green { background: #27ca40; }

    .boss-terminal-title {
      flex: 1;
      text-align: center;
      color: #ff9900;
      font-weight: bold;
      letter-spacing: 0.2rem;
      font-size: 1rem;
    }

    .boss-chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      scroll-behavior: smooth;
    }

    .chat-message {
      max-width: 80%;
      padding: 0.75rem 1rem;
      border-radius: 8px;
      line-height: 1.5;
    }

    .chat-message.ai {
      background: rgba(255, 165, 0, 0.15);
      border: 1px solid #ff9900;
      color: #ffaa33;
      align-self: flex-start;
    }

    .chat-message.user {
      background: rgba(0, 255, 0, 0.15);
      border: 1px solid #00ff00;
      color: #00ff00;
      align-self: flex-end;
    }

    .chat-message .sender {
      font-size: 0.75rem;
      opacity: 0.7;
      margin-bottom: 0.25rem;
    }

    .chat-message.ai .sender { color: #ff9900; }
    .chat-message.user .sender { color: #00ff00; }

    /* Streaming cursor animation */
    .streaming-cursor {
      color: #ff9900;
      animation: blink 0.7s infinite;
    }
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    .chat-message.system {
      background: rgba(100, 100, 100, 0.3);
      border: 1px solid #666;
      color: #999;
      align-self: center;
      max-width: 90%;
      text-align: center;
      font-style: italic;
      padding: 0.4rem 1rem;
    }

    .chat-message.system .system-content {
      font-size: 1rem;
    }

    .boss-player-info {
      text-align: center;
      padding: 1rem;
      border-bottom: 1px solid #333;
      background: rgba(255, 153, 0, 0.05);
    }

    .boss-player-info .label {
      color: #666;
      font-size: 0.8rem;
      margin-bottom: 0.25rem;
    }

    .boss-player-info .player-name {
      color: #00ff00;
      font-size: 1.5rem;
      font-weight: bold;
    }

    .boss-player-info .instruction {
      color: #ff9900;
      font-size: 1rem;
      margin-top: 0.5rem;
      animation: pulse 2s ease-in-out infinite;
    }

    .typing-indicator {
      color: #999;
      font-style: italic;
      padding: 0.5rem 1rem;
    }

    .typing-indicator span {
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* Chat input section */
    .boss-input-section {
      display: flex;
      gap: 0.5rem;
      padding: 1rem;
      border-top: 1px solid #333;
      background: rgba(0, 0, 0, 0.5);
    }

    .boss-message-input {
      flex: 1;
      background: #1a1a1a;
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 0.75rem 1rem;
      font-family: 'Courier New', monospace;
      font-size: 1.1rem;
      border-radius: 5px;
    }

    .boss-message-input:focus {
      outline: none;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
    }

    .boss-message-input:disabled {
      opacity: 0.5;
    }

    .typing-indicator {
      align-self: flex-start;
      background: rgba(150, 150, 150, 0.15);
      border: 1px dashed #888;
      border-radius: 8px;
      padding: 0.5rem 1rem;
      margin: 0;
    }

    .typing-indicator.hidden {
      display: none;
    }

    /* Firewall Health Bar */
    .firewall-section {
      width: 100%;
      max-width: 900px;
      margin-top: 1rem;
    }

    .firewall-section.hidden {
      display: none;
    }

    .firewall-container {
      display: flex;
      align-items: center;
      gap: 1rem;
      background: rgba(255, 0, 0, 0.1);
      border: 1px solid #ff4444;
      border-radius: 8px;
      padding: 0.75rem 1rem;
    }

    .firewall-label {
      font-size: 1rem;
      font-weight: bold;
      color: #ff4444;
      text-transform: uppercase;
      letter-spacing: 0.1rem;
      white-space: nowrap;
    }

    .firewall-bar {
      flex: 1;
      height: 30px;
      background: #1a1a1a;
      border-radius: 5px;
      overflow: hidden;
      position: relative;
    }

    .firewall-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff0000, #ff4444);
      box-shadow: 0 0 15px rgba(255, 68, 68, 0.6);
      transition: width 0.5s ease;
    }

    .firewall-fill.low {
      background: linear-gradient(90deg, #880000, #ff0000);
      animation: firewallPulse 0.5s ease-in-out infinite;
    }

    .firewall-fill.critical {
      background: linear-gradient(90deg, #550000, #aa0000);
      animation: firewallPulse 0.3s ease-in-out infinite;
    }

    @keyframes firewallPulse {
      0%, 100% { box-shadow: 0 0 15px rgba(255, 68, 68, 0.6); }
      50% { box-shadow: 0 0 25px rgba(255, 0, 0, 0.9); }
    }

    .firewall-hp {
      font-size: 1.2rem;
      font-weight: bold;
      color: #ff4444;
      width: 60px;
      text-align: center;
    }

    .firewall-hp.low {
      color: #ff0000;
      animation: hpBlink 0.5s ease-in-out infinite;
    }

    .firewall-hp.critical {
      color: #ff0000;
      animation: hpBlink 0.3s ease-in-out infinite;
    }

    @keyframes hpBlink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Core Phase Chat Section */
    .core-section {
      width: 100%;
      max-width: 900px;
      margin-top: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .core-section.hidden {
      display: none;
    }

    .core-terminal {
      background: #0d0d0d;
      border: 2px solid #ff00ff;
      border-radius: 10px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 60vh;
      animation: corePulse 2s ease-in-out infinite;
    }

    @keyframes corePulse {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 0, 255, 0.3); }
      50% { box-shadow: 0 0 40px rgba(255, 0, 255, 0.6); }
    }

    .core-terminal-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem 1rem;
      background: linear-gradient(180deg, #2a0a2a 0%, #1a0a1a 100%);
      border-bottom: 1px solid #ff00ff;
    }

    .core-terminal-title {
      margin-left: auto;
      margin-right: auto;
      color: #ff00ff;
      font-weight: bold;
      font-size: 0.9rem;
      letter-spacing: 0.1rem;
      text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
    }

    .core-chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      background: linear-gradient(180deg, #1a0a1a 0%, #0d050d 100%);
    }

    /* Core chat messages - magenta theme */
    .core-chat-message {
      padding: 0.75rem 1rem;
      border-radius: 8px;
      max-width: 85%;
      word-wrap: break-word;
    }

    .core-chat-message.user {
      background: rgba(0, 255, 0, 0.15);
      border: 1px solid #00ff00;
      color: #00ff00;
      align-self: flex-end;
    }

    .core-chat-message.ai {
      background: rgba(255, 0, 255, 0.15);
      border: 1px solid #ff00ff;
      color: #ff00ff;
      align-self: flex-start;
    }

    .core-chat-message .sender {
      font-size: 0.75rem;
      opacity: 0.7;
      margin-bottom: 0.25rem;
      text-transform: uppercase;
      letter-spacing: 0.05rem;
    }

    .core-chat-message .content {
      font-size: 1rem;
      line-height: 1.4;
    }

    .core-chat-message.system {
      background: rgba(100, 100, 100, 0.3);
      border: 1px solid #666;
      color: #999;
      align-self: center;
      max-width: 90%;
      text-align: center;
      font-style: italic;
      padding: 0.4rem 1rem;
    }

    /* Core streaming cursor */
    .core-chat-message.streaming .streaming-cursor {
      color: #ff00ff;
      animation: blink 0.7s infinite;
    }

    .core-typing-indicator {
      align-self: flex-start;
      background: rgba(255, 0, 255, 0.1);
      border: 1px dashed #ff00ff;
      border-radius: 8px;
      padding: 0.5rem 1rem;
      color: #ff00ff;
      font-style: italic;
    }

    .core-typing-indicator span {
      animation: blink 1s infinite;
    }

    /* Core password section */
    .core-password-section {
      background: rgba(255, 0, 255, 0.1);
      border: 2px solid #ff00ff;
      border-radius: 10px;
      padding: 1rem 1.5rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
    }

    .core-password-label {
      font-size: 1rem;
      font-weight: bold;
      color: #ff00ff;
      text-transform: uppercase;
      letter-spacing: 0.15rem;
      text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
    }

    .core-password-row {
      display: flex;
      gap: 1rem;
      width: 100%;
      max-width: 400px;
    }

    .core-password-input {
      flex: 1;
      padding: 0.75rem 1rem;
      font-size: 1.1rem;
      font-family: inherit;
      background: #0d0d0d;
      border: 2px solid #ff00ff;
      border-radius: 5px;
      color: #ff00ff;
      text-transform: uppercase;
      letter-spacing: 0.1rem;
      text-align: center;
    }

    .core-password-input:focus {
      outline: none;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
    }

    .core-password-input::placeholder {
      color: #666;
      text-transform: none;
    }

    .core-submit-btn {
      padding: 0.75rem 1.5rem;
      font-size: 1.1rem;
      font-family: inherit;
      font-weight: bold;
      background: #ff00ff;
      border: none;
      border-radius: 5px;
      color: #000;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.1rem;
      transition: all 0.3s ease;
    }

    .core-submit-btn:hover {
      box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
      transform: scale(1.05);
    }

    .core-password-message {
      font-size: 1rem;
      padding: 0.5rem 1rem;
      border-radius: 5px;
      text-align: center;
    }

    .core-password-message.error {
      color: #ff4444;
      background: rgba(255, 68, 68, 0.1);
    }

    .core-password-message.success {
      color: #00ff00;
      background: rgba(0, 255, 0, 0.1);
    }

    /* ========== VICTORY SCREEN ========== */
    .victory-section {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .victory-section.hidden {
      display: none;
    }

    .victory-container {
      text-align: center;
      animation: victoryFadeIn 2s ease-out;
    }

    @keyframes victoryFadeIn {
      from { opacity: 0; transform: scale(0.8); }
      to { opacity: 1; transform: scale(1); }
    }

    .victory-glitch {
      font-size: 5rem;
      font-weight: bold;
      color: #00ff00;
      text-shadow:
        0 0 10px #00ff00,
        0 0 20px #00ff00,
        0 0 40px #00ff00,
        0 0 80px #00ff00;
      animation: victoryPulse 2s ease-in-out infinite, glitchText 0.3s infinite;
      position: relative;
    }

    @keyframes victoryPulse {
      0%, 100% {
        text-shadow:
          0 0 10px #00ff00,
          0 0 20px #00ff00,
          0 0 40px #00ff00;
      }
      50% {
        text-shadow:
          0 0 20px #00ff00,
          0 0 40px #00ff00,
          0 0 80px #00ff00,
          0 0 120px #00ff00;
      }
    }

    @keyframes glitchText {
      0%, 90%, 100% { transform: translate(0); }
      92% { transform: translate(-2px, 1px); }
      94% { transform: translate(2px, -1px); }
      96% { transform: translate(-1px, 2px); }
      98% { transform: translate(1px, -2px); }
    }

    .victory-subtitle {
      font-size: 1.5rem;
      color: #ff00ff;
      margin-top: 1rem;
      text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
      animation: subtitleFade 3s ease-out forwards;
      animation-delay: 1s;
      opacity: 0;
    }

    @keyframes subtitleFade {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .victory-message {
      font-size: 1.2rem;
      color: #888;
      margin-top: 2rem;
      animation: subtitleFade 3s ease-out forwards;
      animation-delay: 2s;
      opacity: 0;
    }

    .victory-credits {
      margin-top: 3rem;
      animation: subtitleFade 3s ease-out forwards;
      animation-delay: 3s;
      opacity: 0;
    }

    .credits-line {
      font-size: 2rem;
      color: #ff9900;
      text-shadow: 0 0 20px rgba(255, 153, 0, 0.5);
    }

    /* ========== GLITCH EFFECTS ========== */
    .flash-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 50;
      border-radius: 10px;
      box-shadow: inset 0 0 0 rgba(255, 0, 0, 0);
    }

    .flash-overlay.active {
      animation: flashPulse 0.6s ease-out forwards;
    }

    @keyframes flashPulse {
      0% { box-shadow: inset 0 0 0 rgba(255, 0, 0, 0); }
      20% { box-shadow: inset 0 0 120px rgba(255, 0, 0, 0.8); }
      50% { box-shadow: inset 0 0 80px rgba(255, 0, 0, 0.6); }
      100% { box-shadow: inset 0 0 0 rgba(255, 0, 0, 0); }
    }

    .glitch-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 51;
      opacity: 0;
      border-radius: 10px;
    }

    .glitch-overlay.active {
      animation: screenGlitch 0.2s steps(3) infinite;
      background: rgba(255, 0, 0, 0.15);
      opacity: var(--overlay-strength, 1);
    }

    @keyframes screenGlitch {
      0% { clip-path: inset(40% 0 30% 0); transform: translate(-20px, 0) skew(-5deg); }
      15% { clip-path: inset(5% 0 70% 0); transform: translate(25px, -12px) skew(6deg); background: rgba(0, 255, 255, 0.2); }
      30% { clip-path: inset(60% 0 10% 0); transform: translate(-18px, 8px) skew(-4deg); background: rgba(255, 0, 255, 0.15); }
      45% { clip-path: inset(15% 0 55% 0); transform: translate(20px, -6px) skew(5deg); background: rgba(255, 255, 0, 0.1); }
      60% { clip-path: inset(45% 0 25% 0); transform: translate(-22px, 10px) skew(-6deg); background: rgba(0, 255, 0, 0.15); }
      75% { clip-path: inset(25% 0 45% 0); transform: translate(15px, -8px) skew(4deg); background: rgba(255, 0, 0, 0.2); }
      90% { clip-path: inset(80% 0 5% 0); transform: translate(-10px, 5px); background: rgba(0, 0, 255, 0.15); }
      100% { clip-path: inset(0 0 100% 0); transform: translate(0, 0); }
    }

    .glitch-overlay::before {
      content: '';
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: repeating-linear-gradient(0deg, rgba(0,0,0,0) 0px, rgba(0,0,0,0) 1px, rgba(0,255,255,0.08) 1px, rgba(0,255,255,0.08) 2px);
    }

    .glitch-overlay::after {
      content: '';
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(90deg, rgba(255,0,0,0.25) 0%, transparent 33%, rgba(0,255,0,0.25) 66%, rgba(0,0,255,0.25) 100%);
      mix-blend-mode: screen;
    }

    @keyframes subtleGlitch {
      0%, 92%, 100% { transform: translate(0); filter: none; }
      93% { transform: translate(-3px, 2px); filter: hue-rotate(15deg); }
      95% { transform: translate(4px, -2px); filter: hue-rotate(-15deg); }
      97% { transform: translate(-2px, -2px); filter: saturate(1.3); }
      99% { transform: translate(2px, 2px); filter: saturate(0.7); }
    }

    @keyframes mediumGlitch {
      0%, 85%, 100% { transform: translate(0) skew(0); filter: none; }
      86% { transform: translate(-5px, 3px) skew(-0.5deg); filter: hue-rotate(20deg); }
      88% { transform: translate(6px, -3px) skew(0.5deg); filter: hue-rotate(-25deg); }
      90% { transform: translate(-4px, -2px) skew(-0.3deg); filter: saturate(1.5) brightness(1.1); }
      92% { transform: translate(4px, 3px) skew(0.3deg); filter: saturate(0.6) brightness(0.9); }
      94% { transform: translate(-3px, 4px); filter: hue-rotate(15deg); }
    }

    @keyframes heavyGlitch {
      0%, 75%, 100% { transform: translate(0) skew(0); filter: none; }
      76% { transform: translate(-8px, 4px) skew(-1deg); filter: hue-rotate(30deg) saturate(1.4); }
      79% { transform: translate(10px, -5px) skew(1deg); filter: hue-rotate(-35deg); }
      82% { transform: translate(-6px, -4px) skew(-0.8deg); filter: saturate(1.8) brightness(1.15); }
      85% { transform: translate(7px, 5px) skew(0.8deg); filter: saturate(0.5) brightness(0.85); }
      88% { transform: translate(-4px, 6px); filter: hue-rotate(25deg); }
      91% { transform: translate(5px, -3px) skew(-0.5deg); filter: hue-rotate(-20deg) saturate(1.3); }
    }

    @keyframes intenseGlitch {
      0%, 60%, 100% { transform: translate(0) skew(0); filter: none; }
      62% { transform: translate(-12px, 6px) skew(-2deg); filter: hue-rotate(45deg) saturate(1.6); }
      66% { transform: translate(15px, -8px) skew(2deg); filter: hue-rotate(-50deg) brightness(1.2); }
      70% { transform: translate(-10px, -6px) skew(-1.5deg); filter: saturate(2) brightness(1.2); }
      74% { transform: translate(12px, 8px) skew(1.5deg); filter: saturate(0.4) brightness(0.8); }
      78% { transform: translate(-8px, 10px) skew(-1deg); filter: hue-rotate(35deg); }
      82% { transform: translate(10px, -6px) skew(1deg); filter: hue-rotate(-40deg) saturate(1.5); }
      86% { transform: translate(-6px, 4px); filter: brightness(1.3) saturate(1.8); }
      90% { transform: translate(8px, -5px) skew(-0.5deg); filter: hue-rotate(25deg); }
    }

    @keyframes screenShake {
      0%, 100% { transform: translate(0); }
      10% { transform: translate(-12px, -8px) rotate(-1deg); }
      20% { transform: translate(14px, 10px) rotate(1deg); }
      30% { transform: translate(-10px, 6px) rotate(-0.5deg); }
      40% { transform: translate(12px, -8px) rotate(0.5deg); }
      50% { transform: translate(-8px, -4px); }
      60% { transform: translate(10px, 6px); }
      70% { transform: translate(-6px, 8px); }
      80% { transform: translate(8px, -6px); }
      90% { transform: translate(-4px, 4px); }
    }

    @keyframes screenShakeIntense {
      0%, 100% { transform: translate(0); }
      5% { transform: translate(-20px, -12px) rotate(-2deg); }
      10% { transform: translate(22px, 15px) rotate(2deg); }
      15% { transform: translate(-18px, 10px) rotate(-1.5deg); }
      20% { transform: translate(20px, -12px) rotate(1.5deg); }
      25% { transform: translate(-15px, -8px) rotate(-1deg); }
      30% { transform: translate(18px, 10px) rotate(1deg); }
      35% { transform: translate(-12px, 14px) rotate(-0.5deg); }
      40% { transform: translate(15px, -10px) rotate(0.5deg); }
      50% { transform: translate(-10px, 8px); }
      60% { transform: translate(12px, -6px); }
      70% { transform: translate(-8px, 10px); }
      80% { transform: translate(10px, -8px); }
      90% { transform: translate(-5px, 5px); }
    }

    .screen-shake { animation: screenShake 0.5s ease-out; }
    .screen-shake-intense { animation: screenShakeIntense 0.6s ease-out; }

    @keyframes breachFlash {
      0% { box-shadow: 0 0 30px rgba(255, 153, 0, 0.3), inset 0 0 0 rgba(255, 0, 0, 0); }
      20% { box-shadow: 0 0 30px rgba(255, 153, 0, 0.3), inset 0 0 120px rgba(255, 0, 0, 0.8); }
      50% { box-shadow: 0 0 30px rgba(255, 153, 0, 0.3), inset 0 0 80px rgba(255, 0, 0, 0.6); }
      100% { box-shadow: 0 0 30px rgba(255, 153, 0, 0.3), inset 0 0 0 rgba(255, 0, 0, 0); }
    }

    .breach-flash { animation: breachFlash 0.6s ease-out; }

    /* Destruction Box Styles */
    .destruction-box {
      width: 100%;
      max-width: 900px;
      margin-top: 1.5rem;
      background: rgba(255, 0, 0, 0.15);
      border: 2px solid #ff0000;
      border-radius: 10px;
      padding: 1.5rem;
      animation: destructionPulse 1s ease-in-out infinite;
    }

    .destruction-box.hidden {
      display: none;
    }

    @keyframes destructionPulse {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 0, 0, 0.4); }
      50% { box-shadow: 0 0 40px rgba(255, 0, 0, 0.7); }
    }

    .destruction-content {
      text-align: center;
    }

    .destruction-header {
      font-size: 1.8rem;
      font-weight: bold;
      color: #ff0000;
      margin-bottom: 0.5rem;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
    }

    .destruction-text {
      color: #ffaaaa;
      margin-bottom: 1rem;
      font-size: 1.1rem;
    }

    .destruction-input-row {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
      margin-bottom: 0.5rem;
    }

    .destruction-input {
      background: #1a0000;
      border: 2px solid #ff0000;
      color: #ff0000;
      padding: 0.75rem 1rem;
      font-family: 'Courier New', monospace;
      font-size: 1.2rem;
      border-radius: 5px;
      width: 250px;
      text-transform: uppercase;
      text-align: center;
    }

    .destruction-input:focus {
      outline: none;
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
    }

    .destruction-submit {
      background: linear-gradient(180deg, #aa0000, #660000);
      border: 2px solid #ff0000;
      color: #fff;
      padding: 0.75rem 1.5rem;
      font-family: 'Courier New', monospace;
      font-size: 1.2rem;
      font-weight: bold;
      border-radius: 5px;
      cursor: pointer;
      text-transform: uppercase;
    }

    .destruction-submit:hover {
      background: linear-gradient(180deg, #cc0000, #880000);
    }

    .destruction-submit:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .destruction-message {
      margin-top: 0.5rem;
      font-size: 1rem;
    }

    .destruction-message.hidden {
      display: none;
    }

    .destruction-message.error {
      color: #ff6666;
    }

    .destruction-message.success {
      color: #00ff00;
      font-size: 1.5rem;
      font-weight: bold;
      animation: successPulse 0.5s ease-in-out infinite;
    }

    @keyframes successPulse {
      0%, 100% { text-shadow: 0 0 10px rgba(0, 255, 0, 0.5); }
      50% { text-shadow: 0 0 20px rgba(0, 255, 0, 0.9); }
    }

    /* Chat Highlighting Styles */
    .player-name {
      font-weight: bold;
    }

    .player-name-blue {
      color: #4488ff;
    }

    .player-name-red {
      color: #ff4444;
    }

    .access-code-highlight {
      font-weight: bold;
      color: #00ff00;
    }

  </style>
</head>
<body>
  <!-- Standby screen shown before game starts -->
  <div class="standby-screen" id="standby-screen">
    <div class="standby-title">AWAITING SIGNAL</div>
    <div class="standby-message">Connecting to mainframe<span class="standby-dots" id="standby-dots">...</span></div>
  </div>

  <!-- Boss phase screen -->
  <div class="boss-screen hidden" id="boss-screen">
    <div class="boss-terminal" id="boss-terminal">
      <div id="flash-overlay" class="flash-overlay"></div>
      <div id="glitch-overlay" class="glitch-overlay"></div>
      <div class="boss-terminal-header">
        <span class="dot red"></span>
        <span class="dot yellow"></span>
        <span class="dot green"></span>
        <span class="boss-terminal-title">Q.W.E.E.N. TERMINAL v6.6.6</span>
      </div>
      <div class="boss-chat-container" id="boss-chat">
        <!-- Chat messages will be rendered here -->
      </div>
    </div>
    <!-- Firewall Health Bar (shown during boss phase) -->
    <div class="firewall-section hidden" id="firewall-section">
      <div class="firewall-container">
        <span class="firewall-label">FIREWALL</span>
        <div class="firewall-bar">
          <div class="firewall-fill" id="firewall-fill"></div>
        </div>
        <span class="firewall-hp" id="firewall-hp">5/5</span>
      </div>
    </div>
    <!-- Victory Screen (shown when game is won) -->
    <div class="victory-section hidden" id="victory-section">
      <div class="victory-container">
        <div class="victory-glitch" data-text="VICTORY">VICTORY</div>
        <div class="victory-subtitle">Q.W.E.E.N. HAS BEEN DESTROYED</div>
        <div class="victory-message">The hackers have saved the day!</div>
        <div class="victory-credits">
          <div class="credits-line">Humanity prevails!</div>
        </div>
      </div>
    </div>
    <!-- Core Phase Chat and Password (shown during core phase) -->
    <div class="core-section hidden" id="core-section">
      <div class="core-terminal">
        <div class="core-terminal-header">
          <span class="dot red"></span>
          <span class="dot yellow"></span>
          <span class="dot green"></span>
          <span class="core-terminal-title">Q.W.E.E.N. CORE ACCESS</span>
        </div>
        <div class="core-chat-container" id="core-chat">
          <!-- Core chat messages will be rendered here (read-only view) -->
        </div>
      </div>
      <div class="core-password-section">
        <div class="core-password-label">DESTRUCTION CODE</div>
        <div class="core-password-row">
          <input type="text" id="core-password" class="core-password-input" placeholder="Enter password..." autocomplete="off">
          <button type="button" id="core-submit-btn" class="core-submit-btn" onclick="submitCorePassword()">DESTROY</button>
        </div>
        <p id="core-password-message" class="core-password-message hidden"></p>
      </div>
    </div>
  </div>

  <h1>HACKING THE MAINFRAME</h1>

  <div class="progress-section">
    <div class="progress-container">
      <span class="team-label blue">BLUE</span>
      <div class="progress-bar">
        <div class="progress-fill blue" id="blue-progress"></div>
      </div>
      <span class="percent blue" id="blue-percent">0%</span>
    </div>
    <div class="progress-container">
      <span class="team-label red">RED</span>
      <div class="progress-bar">
        <div class="progress-fill red" id="red-progress"></div>
      </div>
      <span class="percent red" id="red-percent">0%</span>
    </div>
  </div>

  <div class="teams-section">
    <div class="team-box blue" id="blue-team">
      <div class="team-title">BLUE PILL</div>
      <div class="top-players" id="blue-top"></div>
    </div>
    <div class="team-box red" id="red-team">
      <div class="team-title">RED PILL</div>
      <div class="top-players" id="red-top"></div>
    </div>
  </div>

  <script>
    let lastScores = { red: 0, blue: 0 };
    let gameStarted = false;
    let bossPhase = false;
    let corePhase = false;
    let bossPlayer = null;
    let localChatHistory = []; // Local chat for instant display
    let waitingForAI = false;
    let animatedMessageCount = 0; // How many messages have been fully animated
    let currentlyAnimatingIndex = -1; // Index of message currently being animated (-1 if none)
    let isFirstLoad = true; // Skip animations on page load
    let dotCount = 0;

    // Firewall HP tracking for damage effects
    let lastFirewallHP = 5;
    const FIREWALL_MAX_HP = 5;
    let glitchInterval = null;

    // Track previous leaderboard order per team (stores player ids in order)
    let prevBlueOrder = [];
    let prevRedOrder = [];

    // Player info and access codes for chat highlighting
    let bossPlayerInfo = [];
    let bossAccessCodes = [];

    // Core phase chat state (separate from boss phase)
    let coreChatHistory = [];
    let coreWaitingForAI = false;
    let coreAnimatedMessageCount = 0;
    let coreCurrentlyAnimatingIndex = -1;
    let coreIsFirstLoad = true;
    let coreTypewriterTargetText = '';
    let coreTypewriterDisplayedText = '';
    let coreTypewriterAnimationId = null;
    let lastCoreChatHtml = '';

    // Animate the dots on standby screen
    function animateDots() {
      dotCount = (dotCount + 1) % 4;
      const dots = '.'.repeat(dotCount) || '';
      document.getElementById('standby-dots').textContent = dots;
    }

    // Check game state and show/hide standby/boss screens
    async function checkGameState() {
      try {
        const response = await fetch('/api/game');
        const data = await response.json();
        gameStarted = data.started;
        bossPhase = data.bossPhase;
        corePhase = data.corePhase || false;
        bossPlayer = data.bossPlayer;

        // Store player info and access codes for chat highlighting
        bossPlayerInfo = data.playerInfo || [];
        bossAccessCodes = data.accessCodes || [];

        const standbyScreen = document.getElementById('standby-screen');
        const bossScreen = document.getElementById('boss-screen');
        const firewallSection = document.getElementById('firewall-section');
        const coreSection = document.getElementById('core-section');

        const victorySection = document.getElementById('victory-section');
        const bossTerminal = document.getElementById('boss-terminal');

        if (data.gameWon) {
          // Show victory screen (inside boss-screen container)
          standbyScreen.classList.add('hidden');
          bossScreen.classList.remove('hidden');
          bossTerminal.classList.add('hidden');
          firewallSection.classList.add('hidden');
          coreSection.classList.add('hidden');
          victorySection.classList.remove('hidden');
        } else if (corePhase) {
          // Show core phase screen (chat + password) - hide boss terminal
          standbyScreen.classList.add('hidden');
          bossScreen.classList.remove('hidden');
          victorySection.classList.add('hidden');
          firewallSection.classList.add('hidden');
          bossTerminal.classList.add('hidden');
          coreSection.classList.remove('hidden');
          updateCoreScreen(data);
        } else if (bossPhase) {
          // Show boss phase screen - show boss terminal
          standbyScreen.classList.add('hidden');
          bossScreen.classList.remove('hidden');
          firewallSection.classList.remove('hidden');
          bossTerminal.classList.remove('hidden');
          coreSection.classList.add('hidden');
          updateBossScreen(data);
        } else if (gameStarted) {
          // Show scoreboard
          standbyScreen.classList.add('hidden');
          bossScreen.classList.add('hidden');
          // Clear local chat if we exited boss phase
          if (localChatHistory.length > 0) {
            localChatHistory = [];
            waitingForAI = false;
            animatedMessageCount = 0;
            currentlyAnimatingIndex = -1;
            resetTypewriter();
          }
          // Clear core chat if we exited core phase
          if (coreChatHistory.length > 0) {
            coreChatHistory = [];
            coreWaitingForAI = false;
            coreAnimatedMessageCount = 0;
            coreCurrentlyAnimatingIndex = -1;
            coreIsFirstLoad = true;
            resetCoreTypewriter();
            lastCoreChatHtml = '';
          }
        } else {
          // Show standby screen
          standbyScreen.classList.remove('hidden');
          bossScreen.classList.add('hidden');
          // Clear local chat if game stopped
          if (localChatHistory.length > 0) {
            localChatHistory = [];
            waitingForAI = false;
            animatedMessageCount = 0;
            currentlyAnimatingIndex = -1;
            resetTypewriter();
          }
          // Clear core chat if game stopped
          if (coreChatHistory.length > 0) {
            coreChatHistory = [];
            coreWaitingForAI = false;
            coreAnimatedMessageCount = 0;
            coreCurrentlyAnimatingIndex = -1;
            coreIsFirstLoad = true;
            resetCoreTypewriter();
            lastCoreChatHtml = '';
          }
        }
      } catch (err) {
        console.error('Failed to check game state:', err);
      }
    }

    // Update boss phase screen
    function updateBossScreen(data) {
      // Always sync from server - it's the source of truth
      const serverChat = data.bossChatHistory || [];
      // Filter out system messages with future timestamps (for staggered display)
      const now = Date.now();
      localChatHistory = serverChat.filter(msg => {
        // If message has no timestamp or is not a system message, show it immediately
        if (!msg.timestamp || msg.role !== 'system') return true;
        // Only show system messages whose timestamp has passed
        return msg.timestamp <= now;
      });

      // Use server's aiProcessing flag for "thinking" indicator
      waitingForAI = data.aiProcessing || false;

      // On first load, skip animations - show all messages immediately
      if (isFirstLoad) {
        isFirstLoad = false;
        animatedMessageCount = localChatHistory.length;
        renderChat();
        updateFirewallHP(data.firewallHP, data.firewallMaxHP);
        return;
      }

      // Check if we need to start animating a new message
      // Only start if not currently animating something
      if (currentlyAnimatingIndex === -1) {
        // First, include any non-AI messages that should show immediately
        while (animatedMessageCount < localChatHistory.length &&
               localChatHistory[animatedMessageCount].role !== 'ai') {
          animatedMessageCount++;
        }

        // Then check if there's an AI message to animate
        if (animatedMessageCount < localChatHistory.length &&
            localChatHistory[animatedMessageCount].role === 'ai') {
          currentlyAnimatingIndex = animatedMessageCount;
          // Render first to create the streaming div, THEN start animation
          renderChat();
          setTypewriterTarget(localChatHistory[animatedMessageCount].content);
          // Update firewall health bar
          updateFirewallHP(data.firewallHP, data.firewallMaxHP);
          return;
        }
      }

      renderChat();
      // Update firewall health bar
      updateFirewallHP(data.firewallHP, data.firewallMaxHP);
    }

    // Update the firewall health bar display
    function updateFirewallHP(hp, maxHP) {
      const fill = document.getElementById('firewall-fill');
      const hpText = document.getElementById('firewall-hp');

      if (hp === undefined || maxHP === undefined) return;

      const percent = (hp / maxHP) * 100;
      fill.style.width = percent + '%';
      hpText.textContent = hp + '/' + maxHP;

      // Remove existing state classes
      fill.classList.remove('low', 'critical');
      hpText.classList.remove('low', 'critical');

      // Add state classes based on HP level
      if (hp <= 1) {
        fill.classList.add('critical');
        hpText.classList.add('critical');
      } else if (hp <= 2) {
        fill.classList.add('low');
        hpText.classList.add('low');
      }

      // Detect firewall breach (HP decreased)
      if (hp < lastFirewallHP) {
        triggerBreachEffect();
      }

      // Update damage visual effects
      updateDamageEffects(hp, maxHP);

      // Show/hide destruction box based on HP
      const destructionBox = document.getElementById('destruction-box');
      if (destructionBox) {
        if (hp === 0) {
          destructionBox.classList.remove('hidden');
        } else {
          destructionBox.classList.add('hidden');
        }
      }

      // Track HP for next comparison
      lastFirewallHP = hp;
    }

    // Apply damage visual effects based on HP
    function updateDamageEffects(currentHP, maxHP) {
      const terminal = document.getElementById('boss-terminal');
      if (!terminal) return;

      const normHealth = currentHP / maxHP;
      const damage = maxHP - currentHP;

      // Remove all damage classes
      terminal.classList.remove('damage-1', 'damage-2', 'damage-3', 'damage-4');

      // Add appropriate damage class (for CSS visual effects)
      if (damage >= 1) {
        const damageLevel = Math.min(damage, 4);
        terminal.classList.add(`damage-${damageLevel}`);
      }

      // Update glitch effects based on normalized health
      updateGlitchEffects(normHealth);
    }

    // Trigger immediate breach effect (screen shake, flash, glitch burst)
    function triggerBreachEffect() {
      const terminal = document.getElementById('boss-terminal');
      const glitchOverlay = document.getElementById('glitch-overlay');
      if (!terminal || !glitchOverlay) return;

      // Screen shake at max strength
      triggerShake(1.0, 500);

      // Flash effect (red pulse)
      triggerFlash();

      // Glitch overlay at max strength
      glitchOverlay.style.setProperty('--overlay-strength', 1.0);
      glitchOverlay.classList.add('active');
      setTimeout(() => glitchOverlay.classList.remove('active'), 300);
    }

    // ===========================================
    // GLITCH SYSTEM - FLASH + RANDOM TICK
    // ===========================================
    // Flash: dedicated regular interval (100% chance every interval)
    // Overlay & Shake: random tick loop with probability rolls

    // Flash configuration - regular interval, always fires
    const flashConfig = {
      enabled: true,
      interval: 2000,      // ms between flashes
      strength: 1.0        // 0-1 intensity multiplier
    };

    // Random tick configuration for overlay and shake
    const glitchConfig = {
      enabled: true,
      minInterval: 1000,   // ms - minimum time between ticks
      maxInterval: 3000,   // ms - maximum time between ticks
      effects: {
        overlay: { chance: 0.4, duration: 150, strength: 1.0 },
        shake:   { chance: 0.15, duration: 500, strength: 1.0 }
      }
    };

    let flashIntervalId = null;
    let glitchTimeoutId = null;
    let currentFlashInterval = null;  // Track the interval the loop is running at

    // ===========================================
    // FLASH SYSTEM - Uses separate overlay element
    // ===========================================
    function startFlashLoop() {
      if (!flashConfig.enabled) {
        stopFlashLoop();
        return;
      }
      // Only restart if interval has changed or loop isn't running
      if (flashIntervalId && currentFlashInterval === flashConfig.interval) {
        return;  // Already running at correct interval
      }
      stopFlashLoop();
      currentFlashInterval = flashConfig.interval;
      flashIntervalId = setInterval(triggerFlash, flashConfig.interval);
    }

    function stopFlashLoop() {
      if (flashIntervalId) {
        clearInterval(flashIntervalId);
        flashIntervalId = null;
        currentFlashInterval = null;
      }
    }

    function triggerFlash() {
      const flashOverlay = document.getElementById('flash-overlay');
      if (!flashOverlay) return;

      // Remove and re-add class to restart animation
      flashOverlay.classList.remove('active');
      flashOverlay.offsetHeight;  // Force reflow
      flashOverlay.classList.add('active');

      setTimeout(() => {
        flashOverlay.classList.remove('active');
      }, 600);
    }

    // ===========================================
    // RANDOM TICK SYSTEM - Overlay & Shake
    // ===========================================
    function startGlitchLoop() {
      if (!glitchConfig.enabled) {
        stopGlitchLoop();
        return;
      }
      // Don't restart if already running - the interval params update dynamically
      if (glitchTimeoutId) return;
      scheduleNextTick();
    }

    function stopGlitchLoop() {
      if (glitchTimeoutId) {
        clearTimeout(glitchTimeoutId);
        glitchTimeoutId = null;
      }
    }

    function scheduleNextTick() {
      if (!glitchConfig.enabled) return;

      const delay = glitchConfig.minInterval +
        Math.random() * (glitchConfig.maxInterval - glitchConfig.minInterval);

      glitchTimeoutId = setTimeout(() => {
        triggerGlitchTick();
        scheduleNextTick();
      }, delay);
    }

    // Execute one tick - overlay and shake roll independently
    function triggerGlitchTick() {
      const terminal = document.getElementById('boss-terminal');
      const overlay = document.getElementById('glitch-overlay');
      if (!terminal) return;

      const fx = glitchConfig.effects;

      // Shake effect
      if (Math.random() < fx.shake.chance) {
        triggerShake(fx.shake.strength, fx.shake.duration);
      }

      // Overlay/scanline effect (separate element)
      if (overlay && Math.random() < fx.overlay.chance) {
        overlay.style.setProperty('--overlay-strength', fx.overlay.strength);
        overlay.classList.add('active');
        setTimeout(() => overlay.classList.remove('active'), fx.overlay.duration);
      }
    }

    function triggerShake(strength, duration) {
      const terminal = document.getElementById('boss-terminal');
      if (!terminal) return;

      // Apply shake animation directly to terminal
      // Flash is now on separate overlay element, so no conflict
      // Duration scales with strength: 0.1s (10%) to 0.4s (100%)
      const shakeDuration = 0.1 + (strength - 0.1) / 3;
      terminal.style.animation = `screenShake ${shakeDuration}s ease-out`;

      setTimeout(() => {
        terminal.style.animation = '';
      }, shakeDuration * 1000);
    }

    // Update glitch effects based on normalized health (0 = dead, 1 = full health)
    function updateGlitchEffects(normHealth) {
      // Calculate strength (inverse of health: 0 at full health, 1 at 0 health)
      const strength = 1 - normHealth;

      // At full health, disable all glitch effects
      if (normHealth >= 1) {
        glitchConfig.enabled = false;
        stopGlitchLoop();
        flashConfig.enabled = false;
        stopFlashLoop();
        return;
      }

      // Fixed chances regardless of health level
      // Shake: always 40% chance
      glitchConfig.effects.shake.chance = 0.4;
      glitchConfig.effects.shake.strength = strength * 0.6;

      // Overlay: always 70% chance
      glitchConfig.effects.overlay.chance = 0.7;
      glitchConfig.effects.overlay.strength = strength;

      // Random tick interval: 2s at full health, 1s at 0 health, linear between
      // min = 1s + 1s * normHealth, max = 2 * min
      const minInterval = 1000 + 1000 * normHealth;
      glitchConfig.minInterval = minInterval;
      glitchConfig.maxInterval = 2 * minInterval;

      // Enable glitch loop when damaged
      glitchConfig.enabled = true;
      startGlitchLoop();

      // Flash: only active when normHealth <= 50%
      // Interval: 3s at 50%, 1s at 20%, stays 1s below 20%
      if (normHealth <= 0.5) {
        // Linear between 20% and 50%: at 0.5 → 3000ms, at 0.2 → 1000ms
        // Below 20%: stays at 1000ms
        if (normHealth >= 0.2) {
          // Linear: interval = 1000 + (normHealth - 0.2) / 0.3 * 2000
          flashConfig.interval = 1000 + ((normHealth - 0.2) / 0.3) * 2000;
        } else {
          flashConfig.interval = 1000;
        }
        flashConfig.enabled = true;
        startFlashLoop();
      } else {
        flashConfig.enabled = false;
        stopFlashLoop();
      }
    }

    // Stop all glitch effects
    function stopGlitchEffects() {
      stopFlashLoop();
      stopGlitchLoop();
    }

    // Track last rendered chat state
    let lastChatHtml = '';

    // Typewriter animation state
    let typewriterTargetText = '';     // Full text from server
    let typewriterDisplayedText = '';  // Text currently shown (animated)
    let typewriterAnimationId = null;  // Animation interval ID
    const TYPEWRITER_CHAR_DELAY = 20;  // ms between characters

    // Start or continue typewriter animation
    function animateTypewriter() {
      if (typewriterAnimationId) return; // Already animating

      function tick() {
        if (typewriterDisplayedText.length < typewriterTargetText.length) {
          // Add next character
          typewriterDisplayedText = typewriterTargetText.slice(0, typewriterDisplayedText.length + 1);
          updateStreamingDisplay();
          typewriterAnimationId = setTimeout(tick, TYPEWRITER_CHAR_DELAY);
        } else {
          // Animation complete
          typewriterAnimationId = null;

          // Mark this message as animated
          if (currentlyAnimatingIndex >= 0) {
            // Include the animated message in the count
            animatedMessageCount = currentlyAnimatingIndex + 1;
            currentlyAnimatingIndex = -1;
            resetTypewriter();

            // Also include any non-AI messages that follow (they show immediately)
            while (animatedMessageCount < localChatHistory.length &&
                   localChatHistory[animatedMessageCount].role !== 'ai') {
              animatedMessageCount++;
            }

            // Check if there's another AI message to animate
            if (animatedMessageCount < localChatHistory.length &&
                localChatHistory[animatedMessageCount].role === 'ai') {
              currentlyAnimatingIndex = animatedMessageCount;
              // Render first to create the streaming div, THEN start animation
              renderChat();
              setTypewriterTarget(localChatHistory[animatedMessageCount].content);
              return;
            }
          }

          // Re-render to show updated state
          renderChat();
        }
      }
      tick();
    }

    // Update just the streaming text display (fast path)
    function updateStreamingDisplay() {
      const chatContainer = document.getElementById('boss-chat');
      const streamingDiv = chatContainer.querySelector('.chat-message.ai.streaming .content');
      if (streamingDiv) {
        streamingDiv.innerHTML = formatWithNewlines(typewriterDisplayedText, true) + '<span class="streaming-cursor">_</span>';
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }
    }

    // Set new target text for typewriter
    function setTypewriterTarget(newText) {
      if (newText === typewriterTargetText) return; // No change

      // If new text is longer and starts with current, just extend
      if (newText.startsWith(typewriterTargetText)) {
        typewriterTargetText = newText;
        animateTypewriter();
      } else {
        // Text changed completely (shouldn't happen often) - reset
        typewriterTargetText = newText;
        typewriterDisplayedText = '';
        animateTypewriter();
      }
    }

    // Check if typewriter is still catching up
    function isTypewriterCatchingUp() {
      return typewriterTargetText && typewriterDisplayedText.length < typewriterTargetText.length;
    }

    // Reset typewriter (only call when starting fresh, not when streaming ends)
    function resetTypewriter() {
      if (typewriterAnimationId) {
        clearTimeout(typewriterAnimationId);
        typewriterAnimationId = null;
      }
      typewriterTargetText = '';
      typewriterDisplayedText = '';
    }

    // Render the chat messages - only update if content changed
    function renderChat() {
      const chatContainer = document.getElementById('boss-chat');
      const catchingUp = isTypewriterCatchingUp();

      // Fast path: only update streaming text content
      const streamingDiv = chatContainer.querySelector('.chat-message.ai.streaming .content');
      if (catchingUp && streamingDiv) {
        // Typewriter animation handles updates via updateStreamingDisplay
        return;
      }

      // Show messages up to and including currentlyAnimatingIndex (if animating)
      // or up to animatedMessageCount (if not animating)
      const showUpTo = currentlyAnimatingIndex >= 0 ? currentlyAnimatingIndex : animatedMessageCount;

      let html = '';
      for (let i = 0; i < showUpTo; i++) {
        const msg = localChatHistory[i];
        // System messages (disconnect notifications)
        if (msg.role === 'system') {
          html += `
          <div class="chat-message system">
            <div class="system-content">${escapeHtml(msg.content)}</div>
          </div>
        `;
        } else if (msg.role === 'user') {
          // User messages - green, right-aligned
          html += `
          <div class="chat-message user">
            <div class="sender">${escapeHtml(msg.senderName || 'HACKER')}</div>
            <div class="content">${formatWithNewlines(msg.content, false)}</div>
          </div>
        `;
        } else {
          // AI messages
          html += `
          <div class="chat-message ai">
            <div class="sender">Q.W.E.E.N.</div>
            <div class="content">${formatWithNewlines(msg.content, true)}</div>
          </div>
        `;
        }
      }

      // Add animated AI message if currently animating
      if (currentlyAnimatingIndex >= 0) {
        html += `
        <div class="chat-message ai streaming">
          <div class="sender">Q.W.E.E.N.</div>
          <div class="content">${formatWithNewlines(typewriterDisplayedText, true)}<span class="streaming-cursor">_</span></div>
        </div>
        `;
      } else if (waitingForAI) {
        // Show typing indicator while waiting for AI to respond (and not animating)
        html += `<div class="typing-indicator">Q.W.E.E.N. is processing<span>...</span></div>`;
      }

      // Only update DOM if content changed
      if (html !== lastChatHtml) {
        chatContainer.innerHTML = html;
        lastChatHtml = html;
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }
    }


    // Stable sort: only move up if you have STRICTLY more points than the person above
    function stableSortPlayers(players, prevOrder) {
      // First, sort by score descending
      const sorted = [...players].sort((a, b) => (b.score || 0) - (a.score || 0));

      // Apply stability: if scores are equal, preserve previous order
      sorted.sort((a, b) => {
        const scoreA = a.score || 0;
        const scoreB = b.score || 0;

        // If scores are different, higher score wins
        if (scoreA !== scoreB) {
          return scoreB - scoreA;
        }

        // Scores are equal - preserve previous order (lower index = higher rank)
        const prevIndexA = prevOrder.indexOf(a.id);
        const prevIndexB = prevOrder.indexOf(b.id);

        // If neither was in previous order, maintain current order
        if (prevIndexA === -1 && prevIndexB === -1) return 0;
        // If only A was in previous order, A stays ahead
        if (prevIndexB === -1) return -1;
        // If only B was in previous order, B stays ahead
        if (prevIndexA === -1) return 1;
        // Both were in previous order - maintain that order
        return prevIndexA - prevIndexB;
      });

      return sorted;
    }

    async function updateScoreboard() {
      try {
        const [scoresRes, guestsRes] = await Promise.all([
          fetch('/api/scores'),
          fetch('/api/guests')
        ]);

        const scores = await scoresRes.json();
        const guests = await guestsRes.json();

        // Use pre-calculated percentages (accumulated with rate)
        const bluePercent = Math.min(100, Math.round(scores.bluePercent || 0));
        const redPercent = Math.min(100, Math.round(scores.redPercent || 0));

        // Update progress bars
        document.getElementById('blue-progress').style.width = bluePercent + '%';
        document.getElementById('red-progress').style.width = redPercent + '%';
        document.getElementById('blue-percent').textContent = bluePercent + '%';
        document.getElementById('red-percent').textContent = redPercent + '%';

        // Get top 3 players per team with stable sorting
        const blueFiltered = guests.filter(g => g.team === 'blue');
        const redFiltered = guests.filter(g => g.team === 'red');

        const bluePlayers = stableSortPlayers(blueFiltered, prevBlueOrder).slice(0, 3);
        const redPlayers = stableSortPlayers(redFiltered, prevRedOrder).slice(0, 3);

        // Update previous order for next refresh
        prevBlueOrder = stableSortPlayers(blueFiltered, prevBlueOrder).map(p => p.id);
        prevRedOrder = stableSortPlayers(redFiltered, prevRedOrder).map(p => p.id);

        // Render top players - only update if content changed
        const blueTopEl = document.getElementById('blue-top');
        const redTopEl = document.getElementById('red-top');
        const newBlueHtml = renderTopPlayers(bluePlayers);
        const newRedHtml = renderTopPlayers(redPlayers);

        if (blueTopEl.innerHTML !== newBlueHtml) {
          blueTopEl.innerHTML = newBlueHtml;
        }
        if (redTopEl.innerHTML !== newRedHtml) {
          redTopEl.innerHTML = newRedHtml;
        }

        // Highlight winning team - only change if winner changed
        const blueBox = document.getElementById('blue-team');
        const redBox = document.getElementById('red-team');
        const blueWinning = scores.blue > scores.red;
        const redWinning = scores.red > scores.blue;

        if (blueWinning && !blueBox.classList.contains('winning')) {
          blueBox.classList.add('winning');
        } else if (!blueWinning && blueBox.classList.contains('winning')) {
          blueBox.classList.remove('winning');
        }

        if (redWinning && !redBox.classList.contains('winning')) {
          redBox.classList.add('winning');
        } else if (!redWinning && redBox.classList.contains('winning')) {
          redBox.classList.remove('winning');
        }

        lastScores = { ...scores };
      } catch (err) {
        console.error('Failed to update scoreboard:', err);
      }
    }

    function renderTopPlayers(players) {
      if (players.length === 0) {
        return '<div class="no-players">No players yet</div>';
      }

      const ranks = ['first', 'second', 'third'];
      return players.map((p, i) => `
        <div class="top-player">
          <span class="rank ${ranks[i]}">#${i + 1}</span>
          <span class="player-name">${escapeHtml(p.hackerName)}</span>
          <span class="player-pts">${p.score || 0}</span>
        </div>
      `).join('');
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function escapeRegex(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function formatWithNewlines(text, isAiMessage = false) {
      let result = escapeHtml(text);

      // Highlight player names in bold with team color (case-insensitive)
      for (const player of bossPlayerInfo) {
        if (player.name) {
          const colorClass = player.team === 'blue' ? 'player-name-blue' : 'player-name-red';
          const escapedName = escapeHtml(player.name);
          // Use word boundary to match whole names only, case-insensitive
          const regex = new RegExp(`\\b${escapeRegex(escapedName)}\\b`, 'gi');
          result = result.replace(regex, `<span class="player-name ${colorClass}">$&</span>`);
        }
      }

      // Highlight access codes in bold green (only in AI messages, only from non-disconnected players)
      if (isAiMessage) {
        // Get access codes from non-disconnected players
        // Note: We include saved players because they may have JUST been saved by this message
        const activeAccessCodes = bossPlayerInfo
          .filter(p => p.accessCode && !p.disconnected)
          .map(p => p.accessCode);

        for (const code of activeAccessCodes) {
          const regex = new RegExp(`\\b${escapeRegex(code)}\\b`, 'gi');
          result = result.replace(regex, `<span class="access-code-highlight">$&</span>`);
        }
      }

      return result.replace(/\n/g, '<br>');
    }

    // Format core phase messages - only highlight player names, not access codes
    function formatCoreMessage(text) {
      let result = escapeHtml(text);

      // Highlight player names in bold with team color (case-insensitive)
      for (const player of bossPlayerInfo) {
        if (player.name) {
          const colorClass = player.team === 'blue' ? 'player-name-blue' : 'player-name-red';
          const escapedName = escapeHtml(player.name);
          // Use word boundary to match whole names only, case-insensitive
          const regex = new RegExp(`\\b${escapeRegex(escapedName)}\\b`, 'gi');
          result = result.replace(regex, `<span class="player-name ${colorClass}">$&</span>`);
        }
      }

      return result.replace(/\n/g, '<br>');
    }

    // ================== CORE PHASE CHAT ==================

    // Update core phase screen
    function updateCoreScreen(data) {
      // Sync core chat history from server
      const serverChat = data.coreChatHistory || [];
      coreChatHistory = [...serverChat];
      coreWaitingForAI = data.coreAiProcessing || false;

      // On first load, skip animations
      if (coreIsFirstLoad) {
        coreIsFirstLoad = false;
        coreAnimatedMessageCount = coreChatHistory.length;
        renderCoreChat();
        return;
      }

      // Check if we need to animate a new message
      if (coreCurrentlyAnimatingIndex === -1) {
        // Include non-AI messages immediately
        while (coreAnimatedMessageCount < coreChatHistory.length &&
               coreChatHistory[coreAnimatedMessageCount].role !== 'ai') {
          coreAnimatedMessageCount++;
        }

        // Check for AI message to animate
        if (coreAnimatedMessageCount < coreChatHistory.length &&
            coreChatHistory[coreAnimatedMessageCount].role === 'ai') {
          coreCurrentlyAnimatingIndex = coreAnimatedMessageCount;
          renderCoreChat();
          setCoreTypewriterTarget(coreChatHistory[coreAnimatedMessageCount].content);
          return;
        }
      }

      renderCoreChat();
    }

    // Core typewriter animation
    const CORE_TYPEWRITER_DELAY = 20;

    function animateCoreTypewriter() {
      if (coreTypewriterAnimationId) return;

      function tick() {
        if (coreTypewriterDisplayedText.length < coreTypewriterTargetText.length) {
          coreTypewriterDisplayedText = coreTypewriterTargetText.slice(0, coreTypewriterDisplayedText.length + 1);
          updateCoreStreamingDisplay();
          coreTypewriterAnimationId = setTimeout(tick, CORE_TYPEWRITER_DELAY);
        } else {
          coreTypewriterAnimationId = null;

          if (coreCurrentlyAnimatingIndex >= 0) {
            coreAnimatedMessageCount = coreCurrentlyAnimatingIndex + 1;
            coreCurrentlyAnimatingIndex = -1;
            resetCoreTypewriter();

            // Include following non-AI messages
            while (coreAnimatedMessageCount < coreChatHistory.length &&
                   coreChatHistory[coreAnimatedMessageCount].role !== 'ai') {
              coreAnimatedMessageCount++;
            }

            // Check for next AI message
            if (coreAnimatedMessageCount < coreChatHistory.length &&
                coreChatHistory[coreAnimatedMessageCount].role === 'ai') {
              coreCurrentlyAnimatingIndex = coreAnimatedMessageCount;
              renderCoreChat();
              setCoreTypewriterTarget(coreChatHistory[coreAnimatedMessageCount].content);
              return;
            }
          }

          renderCoreChat();
        }
      }
      tick();
    }

    function updateCoreStreamingDisplay() {
      const chatContainer = document.getElementById('core-chat');
      const streamingDiv = chatContainer.querySelector('.core-chat-message.streaming .content');
      if (streamingDiv) {
        streamingDiv.innerHTML = formatCoreMessage(coreTypewriterDisplayedText) + '<span class="streaming-cursor">_</span>';
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }
    }

    function setCoreTypewriterTarget(newText) {
      if (newText === coreTypewriterTargetText) return;

      if (newText.startsWith(coreTypewriterTargetText)) {
        coreTypewriterTargetText = newText;
        animateCoreTypewriter();
      } else {
        coreTypewriterTargetText = newText;
        coreTypewriterDisplayedText = '';
        animateCoreTypewriter();
      }
    }

    function isCoreTypewriterCatchingUp() {
      return coreTypewriterTargetText && coreTypewriterDisplayedText.length < coreTypewriterTargetText.length;
    }

    function resetCoreTypewriter() {
      if (coreTypewriterAnimationId) {
        clearTimeout(coreTypewriterAnimationId);
        coreTypewriterAnimationId = null;
      }
      coreTypewriterTargetText = '';
      coreTypewriterDisplayedText = '';
    }

    // Render core chat messages
    function renderCoreChat() {
      const chatContainer = document.getElementById('core-chat');
      const catchingUp = isCoreTypewriterCatchingUp();

      // Fast path: typewriter handles updates
      const streamingDiv = chatContainer.querySelector('.core-chat-message.streaming .content');
      if (catchingUp && streamingDiv) {
        return;
      }

      const showUpTo = coreCurrentlyAnimatingIndex >= 0 ? coreCurrentlyAnimatingIndex : coreAnimatedMessageCount;

      let html = '';
      for (let i = 0; i < showUpTo; i++) {
        const msg = coreChatHistory[i];
        // Skip GAME_MASTER messages (used internally to prompt AI)
        if (msg.senderName === 'GAME_MASTER' || msg.role === 'gamemaster') {
          continue;
        } else if (msg.role === 'system') {
          html += `
          <div class="core-chat-message system">
            <div class="system-content">${escapeHtml(msg.content)}</div>
          </div>
        `;
        } else if (msg.role === 'user') {
          html += `
          <div class="core-chat-message user">
            <div class="sender">${escapeHtml(msg.senderName || 'HACKER')}</div>
            <div class="content">${formatCoreMessage(msg.content)}</div>
          </div>
        `;
        } else {
          html += `
          <div class="core-chat-message ai">
            <div class="sender">Q.W.E.E.N.</div>
            <div class="content">${formatCoreMessage(msg.content)}</div>
          </div>
        `;
        }
      }

      // Animated AI message
      if (coreCurrentlyAnimatingIndex >= 0) {
        html += `
        <div class="core-chat-message ai streaming">
          <div class="sender">Q.W.E.E.N.</div>
          <div class="content">${formatCoreMessage(coreTypewriterDisplayedText)}<span class="streaming-cursor">_</span></div>
        </div>
        `;
      } else if (coreWaitingForAI) {
        html += `<div class="core-typing-indicator">Q.W.E.E.N. is processing<span>...</span></div>`;
      }

      if (html !== lastCoreChatHtml) {
        chatContainer.innerHTML = html;
        lastCoreChatHtml = html;
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }
    }

    // Submit destruction password to destroy the AI
    async function submitDestructionPassword() {
      const input = document.getElementById('destruction-password');
      const password = input.value.trim();
      const messageEl = document.getElementById('destruction-message');
      const submitBtn = document.getElementById('destruction-submit-btn');

      if (!password) {
        messageEl.textContent = 'Enter a password!';
        messageEl.classList.remove('hidden', 'success');
        messageEl.classList.add('error');
        return;
      }

      submitBtn.disabled = true;
      submitBtn.textContent = 'DESTROYING...';
      messageEl.classList.add('hidden');

      try {
        const response = await fetch('/api/boss/destroy', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password })
        });

        const data = await response.json();

        if (data.success) {
          input.value = '';
          messageEl.textContent = 'AI DESTROYED! Victory!';
          messageEl.classList.remove('hidden', 'error');
          messageEl.classList.add('success');
        } else {
          messageEl.textContent = data.error || 'Wrong password!';
          messageEl.classList.remove('hidden', 'success');
          messageEl.classList.add('error');
        }
      } catch (err) {
        console.error('Destruction failed:', err);
        messageEl.textContent = 'Connection error!';
        messageEl.classList.remove('hidden', 'success');
        messageEl.classList.add('error');
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = 'DESTROY';
      }
    }

    // Initial load
    checkGameState();
    updateScoreboard();

    // Animate standby dots
    setInterval(animateDots, 500);

    // Dynamic polling rate: faster when AI is streaming, slower otherwise
    let pollTimeoutId = null;

    function schedulePoll(delay) {
      if (pollTimeoutId) clearTimeout(pollTimeoutId);
      pollTimeoutId = setTimeout(poll, delay);
    }

    function poll() {
      const wasWaitingForAI = waitingForAI;
      checkGameState();
      updateScoreboard();
      // If AI just started processing, immediately trigger fast polling
      if (waitingForAI && !wasWaitingForAI) {
        schedulePoll(0); // Immediate next poll
        return;
      }
      // Poll at 300ms when AI is streaming (typewriter handles smoothness), slower (2000ms) otherwise
      const delay = waitingForAI ? 300 : 2000;
      schedulePoll(delay);
    }
    poll();

    // Submit core password
    async function submitCorePassword() {
      const passwordInput = document.getElementById('core-password');
      const messageEl = document.getElementById('core-password-message');
      const submitBtn = document.getElementById('core-submit-btn');
      const password = passwordInput.value.trim();

      if (!password) {
        messageEl.textContent = 'Enter a password!';
        messageEl.classList.remove('hidden', 'success');
        messageEl.classList.add('error');
        return;
      }

      submitBtn.disabled = true;
      submitBtn.textContent = 'DESTROYING...';

      try {
        const response = await fetch('/api/core/destroy', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password })
        });
        const data = await response.json();

        if (data.success) {
          messageEl.textContent = 'Q.W.E.E.N. DESTROYED! You win!';
          messageEl.classList.remove('hidden', 'error');
          messageEl.classList.add('success');
          passwordInput.disabled = true;
          submitBtn.disabled = true;
          submitBtn.textContent = 'DESTROYED';
          // Show victory screen (handled by game state change)
        } else {
          messageEl.textContent = data.error || 'Wrong password!';
          messageEl.classList.remove('hidden', 'success');
          messageEl.classList.add('error');
          submitBtn.disabled = false;
          submitBtn.textContent = 'DESTROY';
        }
      } catch (err) {
        messageEl.textContent = 'Connection error!';
        messageEl.classList.remove('hidden', 'success');
        messageEl.classList.add('error');
        submitBtn.disabled = false;
        submitBtn.textContent = 'DESTROY';
      }
    }

    // Allow Enter key to submit password
    document.getElementById('core-password')?.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        submitCorePassword();
      }
    });

  </script>
</body>
</html>
